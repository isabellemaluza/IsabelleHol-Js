theory JSMemoryModel
  imports Complex_Main
begin

datatype js_vle =
    VNumber real
  | VNaN
  | VBool bool
  | VString string
  | VNull
  | VUndefined
  | VObject "(string * js_vle) list"
  | VFunction "string list" expr "(string * js_vle) list"
  | VTypeError string
and expr =
    EConst js_vle
  | EVar string
  | EAssign string expr
  | EBinOp string expr expr
  | ECall expr "expr list"
  | EIf expr expr expr
  | EReturn expr

type_synonym frame = "(string * js_vle) list"
type_synonym stack = "frame list"
type_synonym heap = "(nat * js_vle) list"
type_synonym event = "string * expr"
type_synonym event_queue = "event list"

record js_state =
  Stack_s :: stack
  Heap_s :: heap
  Events_s :: event_queue

definition init_state :: js_state where
  "init_state = \<lparr>
     Stack_s = [[(''x'', VNumber 10), (''y'', VNumber 20)]],
     Heap_s = [(0, VObject [(''msg'', VString ''Ola'')]),
               (1, VFunction [''a'', ''b''] (EBinOp ''+'' (EVar ''a'') (EVar ''b'')) [])],
     Events_s = [(''click'', ECall (EVar ''handleClick'') [])]
   \<rparr>"

definition another_state :: js_state where
  "another_state = \<lparr>
     Stack_s = [[(''total'', VNumber 0)]],
     Heap_s = [(0, VFunction [''x''] (EAssign ''total'' (EBinOp ''+'' (EVar ''total'') (EVar ''x''))) [])],
     Events_s = [(''keydown'', ECall (EVar ''handleKeyDown'') [])]
   \<rparr>"

fun load_var :: "string \<Rightarrow> js_state \<Rightarrow> js_vle option" where
  "load_var x state =
     (case Stack_s state of
        [] \<Rightarrow> None
      | frame # _ \<Rightarrow> map_of frame x)"

fun write_var :: "string \<Rightarrow> js_vle \<Rightarrow> js_state \<Rightarrow> js_state" where
  "write_var x v state =
     (case Stack_s state of
        [] \<Rightarrow> state
      | frame # rest \<Rightarrow>
          let new_frame = (x, v) # [(k, val) \<leftarrow> frame. k \<noteq> x]
          in state\<lparr>Stack_s := new_frame # rest\<rparr>)"

fun push_frame :: "frame \<Rightarrow> js_state \<Rightarrow> js_state" where
  "push_frame f state = state\<lparr>Stack_s := f # Stack_s state\<rparr>"

fun pop_frame :: "js_state \<Rightarrow> js_state" where
  "pop_frame state =
     (case Stack_s state of
        [] \<Rightarrow> state
      | _ # rest \<Rightarrow> state\<lparr>Stack_s := rest\<rparr>)"

fun alloc_object :: "(string * js_vle) list \<Rightarrow> js_state \<Rightarrow> (nat * js_state)" where
  "alloc_object props state =
     (let new_id = length (Heap_s state);
          new_heap = (new_id, VObject props) # Heap_s state
      in (new_id, state\<lparr>Heap_s := new_heap\<rparr>))"

fun load_object :: "nat \<Rightarrow> js_state \<Rightarrow> js_vle option" where
  "load_object obj_id state =
     (case find (\<lambda>(k, v). k = obj_id) (Heap_s state) of
        None \<Rightarrow> None
      | Some (_, v) \<Rightarrow> Some v)"

fun write_object :: "nat \<Rightarrow> (string * js_vle) list \<Rightarrow> js_state \<Rightarrow> js_state" where
  "write_object obj_id props state =
     (let new_heap = (obj_id, VObject props) # filter (\<lambda>(k, v). k \<noteq> obj_id) (Heap_s state)
      in state\<lparr>Heap_s := new_heap\<rparr>)"


value "VNumber 42"
value "VString ''Hello''"
value "VBool True"
value "EBinOp ''+'' (EVar ''a'') (EVar ''b'')"
value "VFunction [''a'', ''b''] (EBinOp ''+'' (EVar ''a'') (EVar ''b'')) []"
value "init_state"
value "another_state"
value "load_var ''x'' init_state"
value "write_var ''x'' (VNumber 99) init_state"
value "push_frame [(''temp'', VNumber 5)] init_state"
value "pop_frame init_state"
value "alloc_object [(''name'', VString ''Isa'')] init_state"
value "load_object 0 init_state"
value "write_object 0 [(''name'', VString ''Novo'')] init_state"


end


