theory JSMemoryModelCmt
  imports Complex_Main JSMemoryModel
begin

fun eval :: "expr \<Rightarrow> js_state \<Rightarrow> js_vle option" where
  "eval (EConst v) _ = Some v" |
  "eval (EVar x) s = load_var x s" |
  "eval (EAssign x e) s =
     (case eval e s of
        None \<Rightarrow> None
      | Some v \<Rightarrow> Some v)" |
  "eval (EBinOp op e1 e2) s =
     (case (eval e1 s, eval e2 s) of
        (Some (VNumber n1), Some (VNumber n2)) \<Rightarrow>
           (if op = ''+'' then Some (VNumber (n1 + n2)) else None)
      | _ \<Rightarrow> None)" |
  "eval (ECall fargs args) s = None" | 
  "eval (EIf c t e) s =
     (case eval c s of Some (VBool True) \<Rightarrow> eval t s | Some (VBool False) \<Rightarrow> eval e s | _ \<Rightarrow> None)" |
  "eval (EReturn e) s = eval e s"

fun call_function :: "js_vle \<Rightarrow> js_vle list \<Rightarrow> js_state \<Rightarrow> (js_state * js_vle) option" where
  "call_function (VFunction params body clo_env) args s =
     (if length params = length args then
        let frame = zip params args;
            s' = push_frame frame s
        in (case eval body s' of None \<Rightarrow> None | Some v \<Rightarrow> Some (pop_frame s', v))
      else None)" |
  "call_function _ _ _ = None"

lemma eval_body_commute_ab:
  assumes "v1 = VNumber n1" and "v2 = VNumber n2"
  shows "eval (EBinOp ''+'' (EVar ''a'') (EVar ''b'')) (push_frame [(''a'',v1),(''b'',v2)] s)
       = eval (EBinOp ''+'' (EVar ''b'') (EVar ''a'')) (push_frame [(''a'',v1),(''b'',v2)] s)"
proof -
  have "eval (EBinOp ''+'' (EVar ''a'') (EVar ''b'')) (push_frame [(''a'',v1),(''b'',v2)] s)
        = Some (VNumber (n1 + n2))"
    using assms by (simp add: eval.simps load_var.simps push_frame.simps)
  moreover have "eval (EBinOp ''+'' (EVar ''b'') (EVar ''a'')) (push_frame [(''a'',v1),(''b'',v2)] s)
        = Some (VNumber (n2 + n1))"
    using assms by (simp add: eval.simps load_var.simps push_frame.simps)
  ultimately show ?thesis
    by (simp add: add.commute) 
qed

lemma call_function_commute_args:
  assumes "v1 = VNumber n1" and "v2 = VNumber n2"
  shows "call_function (VFunction [''a'',''b''] (EBinOp ''+'' (EVar ''a'') (EVar ''b'')) clo_env) [v1,v2] s
       = call_function (VFunction [''a'',''b''] (EBinOp ''+'' (EVar ''b'') (EVar ''a'')) clo_env) [v1,v2] s"
proof -
  have "eval (EBinOp ''+'' (EVar ''a'') (EVar ''b'')) (push_frame [(''a'',v1),(''b'',v2)] s)
        = eval (EBinOp ''+'' (EVar ''b'') (EVar ''a'')) (push_frame [(''a'',v1),(''b'',v2)] s)"
    using eval_body_commute_ab assms by simp
then show ?thesis
    by (simp add: call_function.simps push_frame.simps eval.simps assms)
qed



end