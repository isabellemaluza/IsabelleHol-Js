theory EvalStack
  imports Main
begin

datatype expr = Const nat | Add expr expr

fun eval_stack :: "expr \<Rightarrow> nat list \<Rightarrow> nat list" where
  "eval_stack (Const n) s = n # s" |
  "eval_stack (Add e1 e2) s =
      (case eval_stack e2 (eval_stack e1 s) of
         x # y # xs \<Rightarrow> (x + y) # xs
       | xs \<Rightarrow> xs)"
fun sum_expr :: "expr \<Rightarrow> nat" where
  "sum_expr (Const n) = n" |
  "sum_expr (Add e1 e2) = sum_expr e1 + sum_expr e2"

value "eval_stack (Const 5) []"                              
value "eval_stack (Add (Const 2) (Const 3)) []"             
value "eval_stack (Add (Add (Const 1) (Const 2)) (Const 4)) []" 
value "eval_stack (Add (Const 10) (Add (Const 2) (Const 3))) []" 
value "eval_stack (Add (Const 7) (Const 8)) [100]"           

lemma eval_stack_sum:
  "sum_list (eval_stack e s) = sum_expr e + sum_list s"
  by (induction e arbitrary: s) auto

lemma eval_stack_empty:
  "eval_stack e [] = [sum_expr e]"
  by (induction e) auto

lemma eval_stack_suffix:
  "\<exists>t. eval_stack e s = t @ s"
  by (induction e arbitrary: s) auto

end
